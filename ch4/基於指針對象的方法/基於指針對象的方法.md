## 基於指針對象的方法

在 Go 語言中，當你定義一個方法時，可以選擇該方法的接收者是值接收者還是指針接收者。這決定了當你調用這個方法時，是傳遞原始對象的一個副本還是傳遞對象的指針。

1. **值接收者**：當方法使用值接收者時，它接收的是原始對象的一個副本。這意味著在方法內部對接收者所做的任何修改都不會影響原始對象。

```
func (p Point) Move(dx, dy float64) {
    p.X += dx
    p.Y += dy
}
```
在上面的例子中，即使我們在 Move 方法中修改了 p，原始的 Point 對象不會被更改。



2. **指針接收者**：當方法使用指針接收者時，它接收的是一個指向原始對象的指針。這意味著你可以在方法內部修改原始對象。

```
func (p *Point) Move(dx, dy float64) {
    p.X += dx
    p.Y += dy
}
```
在這個例子中，Move 方法接收一個 Point 的指針。當我們在方法內部修改 p 時，原始的 Point 對象也會被更改。


#### 為什麼要使用指針接收者？

1. **效能**：對於大的結構體，使用指針可以避免在每次方法調用時複製整個結構體。
2. **修改原始對象**：如上所述，只有使用指針接收者時，才能在方法內部修改原始對象。
3. **一致性**：如果某些方法需要修改原始對象，那麼為了一致性，你可能會選擇使所有方法都使用指針接收者

#### Nil也是一個合法的接收器類型

```
type MyType struct {
    value string
}

func (m *MyType) PrintValue() {
    if m == nil {
        fmt.Println("nil receiver!")
    } else {
        fmt.Println(m.value)
    }
}

func main() {
    var mt *MyType
    mt.PrintValue()  // 輸出: nil receiver!
}

```