## 浮點數

1. 類型:
    - Go 提供了兩種精度的浮點數：float32 和 float64。

2. 標準:
    - 它們遵循 IEEE754 浮點數國際標準，這是現代所有CPU普遍支持的標準。

3. 取值範圍:
    - float32 和 float64 可以表示從非常小到非常大的數值。
    - 最大值：math.MaxFloat32 是大約 3.4e38，而 math.MaxFloat64 是大約 1.8e308。
    - 最小值：約爲 1.4e-45 (對於 float32) 和 4.9e-324 (對於 float64)。

4. 精度:
    - float32 提供大約 6 個十進制數的精度。
    - float64 提供約 15 個十進制數的精度。
    - 建議優先使用 float64，因為 float32 計算中的誤差較容易累積，而且它能精確表示的正整數範圍不大（因為 float32 的有效 bit 位只有23個，其餘的用於指數和符號）。


總之，當在 Go 中處理浮點數時，通常建議使用 float64 以獲得更高的精度和更大的數值範圍。


```
var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
```

浮點數的字面值可以直接寫小數部分，像這樣：

```
const e = 2.71828 // (approximately)
```

小數點前面或後面的數字都可能被省略（例如.707或1.）。
很小或很大的數最好用科學計數法書寫，通過e或E來指定指數部分：

```
const Avogadro = 6.02214129e23  // 阿伏伽德羅常數
const Planck   = 6.62606957e-34 // 普朗剋常數
```

用Printf函數的%g參數打印浮點數，將采用更緊湊的表示形式打印，併提供足夠的精度，但是對應表格的數據，使用%e（帶指數）或%f的形式打印可能更合適。

```
for x := 0; x < 8; x++ {
    fmt.Printf("x = %d e^x = %8.3f\n", x, math.Exp(float64(x)))
}
```

上面代碼打印e的冪，打印精度是小數點後三個小數精度和8個字符寬度：

```
x = 0       e^x =    1.000
x = 1       e^x =    2.718
x = 2       e^x =    7.389
x = 3       e^x =   20.086
x = 4       e^x =   54.598
x = 5       e^x =  148.413
x = 6       e^x =  403.429
x = 7       e^x = 1096.633
```
math包中除了提供大量常用的數學函數外，還提供了IEEE754浮點數標準中定義的特殊值的創建和測試：正無窮大和負無窮大，分别用於表示太大溢出的數字和除零的結果；還有NaN非數，一般用於表示無效的除法操作結果0/0或Sqrt(-1).

```
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
```
函數math.IsNaN用於測試一個數是否是非數NaN，math.NaN則返迴非數對應的值。雖然可以用math.NaN來表示一個非法的結果，但是測試一個結果是否是非數NaN則是充滿風險的，因爲NaN和任何數都是不相等的（譯註：在浮點數中，NaN、正無窮大和負無窮大都不是唯一的，每個都有非常多種的bit模式表示）：

```
nan := math.NaN()
fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
```

如果一個函數返迴的浮點數結果可能失敗，最好的做法是用單獨的標誌報告失敗，像這樣：

```
func compute() (value float64, ok bool) {
    // ...
    if failed {
        return 0, false
    }
    return result, true
}
```
