## 變量 

var聲明語句可以創建一個特定類型的變量，然後給變量附加一個名字，併且設置變量的初始值。變量聲明的一般語法如下：

例如：

```
var 變量名字 類型 = 表達式
```
**類型**或**表達式**兩個部分可以省略其中的一個。

推導類型: 如果你省略了變量的類型信息，Go 會根據初始化表達式自動推導其類型。

例如：

```
var x = 10  // x 被推導為 int 類型
```
零值初始化: 如果你省略了初始化表達式，Go 會使用對應類型的零值來初始化變量。

這些零值包括：

數值類型的零值是 0
布爾類型的零值是 false
字符串類型的零值是空字符串 ""
slice、map、chan和函數的零值是 nil
數組和結構體的零值是其每個元素或字段的零值

例如：

```
var y int    // y 初始化為 0
var z string // z 初始化為 ""
```
這種零值初始化機制確保每一個在 Go 中聲明的變量都會有一個明確的初始值，因此不存在未初始化的變量。這不僅簡化了代碼的編寫，還確保了程序在各種邊界情況下都能正確、安全地運行。

也可以在一個聲明語句中同時聲明一組變量，或用一組初始化表達式聲明併初始化一組變量。如果省略每個變量的類型，將可以聲明多個類型不同的變量（類型由初始化表達式推導）

例如：

```
var i, j, k int // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string 
```

一組變量也可以通過調用一個函數，由函數返迴的多個返迴值初始化

例如：

```
var f, err = os.Open(name) // os.Open returns a file and an error
```

---

## 簡短變量聲明

Go 語言的函數內部，提供了一種簡便的方式來聲明並初始化局部變量，這種方式稱為簡短變量聲明

例如：

```
名字 := 表達式
```

這裡的 := 是簡短變量聲明的關鍵。使用此語法，Go 會自動推導出 名字 的類型，基於 表達式 的類型。

例如：

```
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```

因爲簡潔和靈活的特點，簡短變量聲明被廣泛用於大部分的局部變量的聲明和初始化。

var形式的聲明語句往往是用於需要顯式指定變量類型地方，或者因爲變量稍後會被重新賦值而初始值無關緊要的地方。

例如：

```
i := 100 // an int
var boiling float64 = 100 // a float64
var names []string
var err error
var p Point
```

和var形式聲明變語句一樣，簡短變量聲明語句也可以用來聲明和初始化一組變量

例如：

```
i, j := 0, 1
```

右邊各個的表達式值賦值給左邊對應位置的各個變量

例如：

```
i, j = j, i // 交換 i 和 j 的值
```
和普通var形式的變量聲明語句一樣，簡短變量聲明語句也可以用函數的返迴值來聲明和初始化變量，像下面的os.Open函數調用將返迴兩個值

例如：

```
f, err := os.Open(name)
if err != nil {
    return err
}
// ...use f...
f.Close()
```

---

## 指針

1. 變量與內存:
    
   - 每個變量都有一塊對應的內存空間來保存其值。
      
   - 變量名（如 x）提供了訪問這些值的方式。但有些變量可以透過表達式（如 x[i] 或 x.f）來存取。

   - 這些表達式大部分時間都用於讀取值，但在賦值時它們可以用來設定新值。

2. 指針的概念:

    - 指針保存了另一個變量的內存地址。

    - 每個變量都有一個唯一的內存地址，但不是每個值都有。

    - 通過指針，可以間接地讀取或更新變量的值，即使我們不知道變量的名稱。

3. 指針的操作:

   - 使用 var x int 聲明一個整數變量 x 之後，&x 會獲取該變量的內存地址，結果是一個指向 int 的指針，類型為 *int。
   
   - 如果有一個指針 p 保存了 x 的地址，我們可以說 "p 指向 x" 或 "p 保存了 x 的地址"。

   - *p 可以用來訪問或修改 p 指向的變量的值。


```
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

變量有時候被稱爲可尋址的值。卽使變量由表達式臨時生成，那麽表達式也必鬚能接受&取地址操作。

任何類型的指針的零值都是nil。如果p != nil測試爲眞，那麽p是指向某個有效變量。指針之間也是可以進行相等測試的，隻有當它們指向同一個變量或全部是nil時才相等。


```
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) // "true false false"
```
Go語言中，返迴函數中局部變量的地址也是安全的。例如下面的代碼，調用f函數時創建局部變量v，在局部變量地址被返迴之後依然有效，因爲指針p依然引用這個變量。

```
var p = f()

func f() *int {
    v := 1
    return &v
}
```
每次調用f函數都將返迴不同的結果：

```
fmt.Println(f() == f()) // "false"
```
通過指針來更新變量的值，然後返迴更新後的值，可用在一個表達式中

```
func incr(p *int) int {
    *p++ // 非常重要：隻是增加p指向的變量的值，併不改變p指針！！！
    return *p
}

v := 1
incr(&v)              // side effect: v is now 2
fmt.Println(incr(&v)) // "3" (and v is 3)
```